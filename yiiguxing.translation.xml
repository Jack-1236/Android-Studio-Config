<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="596" />
    <option name="newTranslationDialogX" value="1620" />
    <option name="newTranslationDialogY" value="1070" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="unrecognized Attribute name MODULE (class com.sun.tools.javac.util.UnsharedNameTableNameImpl)" />
      <item value="Caused by: org.gradle.internal.resolve.ModuleVersionNotFoundException: Could not find org.jetbrains.kotlin:kotlin-stdlib-jdk8:2.2.0." />
      <item value="Caused by: org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfigurationArtifactResolveException: Could not resolve all files for configuration ':app:releaseCompileClasspath'." />
      <item value="Cannot access com.dabush.shen.mcrpos.tabs.pricechange.PriceChangeAdapter.MyBaseViewHolder" />
      <item value="org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:compileReleaseJavaWithJavac'." />
      <item value="Failed to apply plugin 'com.android.internal.application'. &gt; Android Gradle plugin requires Java 11 to run. You are cu" />
      <item value="table ids are unsupported on PagingDataAdapter." />
      <item value="Refresh the data presented by this [PagingDataAdapter]. [refresh] triggers the creation of a new [PagingData] with a new instance of [PagingSource] to represent an updated snapshot of the backing dataset. If a [RemoteMediator] is set, calling [refresh] will also trigger a call to [RemoteMediator.load] with [LoadType] [REFRESH] to allow [RemoteMediator] to check for updates to the dataset backing [PagingSource]. Note: This API is intended for UI-driven refresh signals, such as swipe-to-refresh. Invalidation due repository-layer signals, such as DB-updates, should instead use [PagingSource.invalidate]. @see PagingSource.invalidate @sample androidx.paging.samples.refreshSample" />
      <item value="Coerces an index in the list, including placeholders, to closest loaded page in [pages]. This function can be called with [anchorPosition] to fetch the loaded page that is closest to the last accessed index in the list. @param anchorPosition Index in the list, including placeholders. @return The closest loaded [Value] in [pages] to the provided [anchorPosition]. `null` if all loaded [pages] are empty." />
      <item value="anchor Position" />
      <item value="closest Page To Position" />
      <item value="initial Load Size" />
      <item value="Provide a [Key] used for the initial [load] for the next [PagingSource] due to invalidation of this [PagingSource]. The [Key] is provided to [load] via [LoadParams.key]. The [Key] returned by this method should cause [load] to load enough items to fill the viewport around the last accessed position, allowing the next generation to transparently animate in. The last accessed position can be retrieved via [state.anchorPosition][PagingState.anchorPosition], which is typically the top-most or bottom-most item in the viewport due to access being triggered by binding items as they scroll into view. For example, if items are loaded based on integer position keys, you can return [state.anchorPosition][PagingState.anchorPosition]. Alternately, if items contain a key used to load, get the key from the item in the page at index [state.anchorPosition][PagingState.anchorPosition]. @param state [PagingState] of the currently fetched data, which includes the most recently accessed position in the list via [PagingState.anchorPosition]. @return [Key] passed to [load] after invalidation used for initial load of the next generation. The [Key] returned by [getRefreshKey] should load pages centered around user's current viewport. If the correct [Key] cannot be determined, `null` can be returned to allow [load] decide what default key to use." />
      <item value="prev Key" />
      <item value="key Reuse Supported" />
      <item value="Success result object for [PagingSource.load]. @param data Loaded data @param prevKey [Key] for previous page if more data can be loaded in that direction, `null` otherwise. @param nextKey [Key] for next page if more data can be loaded in that direction, `null` otherwise." />
      <item value="pre Key" />
      <item value="initial Key" />
      <item value="Prepend" />
      <item value="get Refresh Key" />
      <item value="Parent job is Cancelling" />
      <item value="anchor Page Index" />
      <item value="Refresh the data presented by this [PagingDataAdapter]. [refresh] triggers the creation of a new [PagingData] with a new instance of [PagingSource] to represent an updated snapshot of the backing dataset. If a [RemoteMediator] is set, calling [refresh] will also trigger a call to [RemoteMediator.load] with [LoadType] [REFRESH] to allow [RemoteMediator] to check for updates to the dataset backing [PagingSource]. Note: This API is intended for UI-driven refresh signals, such as swipe-to-refresh. Invalidation due repository-layer signals, such as DB-updates, should instead use" />
      <item value="Returns a flow containing only values of the original flow that do not match the given" />
      <item value="filter Not" />
      <item value="swap Adapter" />
      <item value="com.example.myonlinelibrary.databinding.LayoutFootholderBindingImpl cannot be cast to com.example.myonlinelibrary.databinding.FragmentLeftItemRecylerviewBinding" />
      <item value="com.example.onlinelibrary.onlineorder.activity.allorder.FootViewHolder cannot be cast to com.example.onlinelibrary.onlineorder.viewholder.SimpleleViewHolder" />
      <item value="A hot [Flow] of [CombinedLoadStates] that emits a snapshot whenever the loading state of the current [PagingData] changes. This flow is conflated, so it buffers the last update to [CombinedLoadStates] and immediately delivers the current load states on collection." />
      <item value="load State Flow" />
      <item value="Method inheritance To ensure the context preservation property, it is not recommended implementing this method directly. Instead, [AbstractFlow] can be used as the base type to properly ensure flow's properties. All default flow implementations ensure context preservation and exception transparency properties on a best-effort basis and throw [IllegalStateException] if a violation was detected." />
      <item value="collect" />
      <item value="filter" />
      <item value="distinct Until Changed By" />
      <item value="end Of Pagination Reached" />
      <item value="Only the original thread that created a view hierarchy can touch its views." />
      <item value="An instance of PagingSource was re-used when Pager expected to create a new instance. Ensure that the pagingSourceFactory passed to Pager always returns a" />
      <item value="An instance of PagingSource was re-used when Pager expected to create a new" />
      <item value="begin Delivery Call Back" />
      <item value="Only emit when REFRESH LoadState changes." />
      <item value="collect Latest" />
      <item value="scroll To Position" />
      <item value="Attempt to invoke virtual method 'com.example.baseandroidaar.baseviewmodel.BaseDataViewModel com.example.onlinelibrary.onlineorder.activity.OrderListActivity.getDataModel()' on a null object reference" />
      <item value="lateinit property refreshFoot has not been initialized" />
      <item value="Error inflating class com.google.android.material.button.MaterialButton" />
      <item value="The style on this component requires your app theme to be Theme.MaterialComponents (or a descendant)." />
      <item value="Error inflating class com.google.android.material.button.MaterialButton Caused by: android.view.InflateException: Binary XML file line 49 in com.example.mcrpos.onlineorder:layoutlayout_footholder: Error inflating class com.google.android.material.button.MaterialButton" />
      <item value="Not Loading" />
      <item value="Loading" />
      <item value="Compiler allocated 4304KB to compile void android.view.ViewRootImpl.performTraversals()" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1220" />
        <entry key="ENGLISH" value="1221" />
        <entry key="GERMAN" value="2" />
        <entry key="FILIPINO" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1669604404429" />
  </component>
  <component name="Settings">
    <option name="translateDocumentation" value="true" />
  </component>
</application>